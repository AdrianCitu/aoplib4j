#summary How to use the test assert modification aspect.

=== Introduction ===
The main idea of the aspect is to modify the way a unit test behaves or to be more specific, how a test assertion violation behaves.

In order to better explain the what I understand by "modify the way a unit test behaves", let's take a very simple JUnit test case:
{{{
    @Test
    public final void assertsTest() {
        String str = null;

        assertNotNull("String str should not be null", str);

        str = "";
               
        assertEquals("String str should have the lenght of 1", str.length(), 1);        
        
    }

}}}

If the test is executed then the output will be the following :

{{{
java.lang.AssertionError: String str should not be null
	at org.junit.Assert.fail(Assert.java:71)
	at org.junit.Assert.assertTrue(Assert.java:34)
	at org.junit.Assert.assertNotNull(Assert.java:359)
	at com.observer.SimpleTest.assertsTest(SimpleTest.java:33)
    ...

}}}

If the test is weaved by the {{{org.aoplib4j.testing.internal.JUnitAspect}}} and then executed, the output will be the following:

{{{
junit.framework.AssertionFailedError: Total number of failed assertions is 2
java.lang.AssertionError: String str should not be null
	at org.junit.Assert.fail(Assert.java:71)
	at org.junit.Assert.assertTrue(Assert.java:34)
	at org.junit.Assert.assertNotNull(Assert.java:359)
	at com.observer.SimpleTest.assertNotNull_aroundBody0(SimpleTest.java:33)
	at com.observer.SimpleTest$AjcClosure1.run(SimpleTest.java:1)
	at org.aspectj.runtime.reflect.JoinPointImpl.proceed(JoinPointImpl.java:149)
  ...
java.lang.AssertionError: String str should have the lenght of 1 expected:<0> but was:<1>
	at org.junit.Assert.fail(Assert.java:71)
	at org.junit.Assert.failNotEquals(Assert.java:451)
	at org.junit.Assert.assertEquals(Assert.java:99)
	at com.observer.SimpleTest.assertEquals_aroundBody2(SimpleTest.java:37)
	at com.observer.SimpleTest$AjcClosure3.run(SimpleTest.java:1)
	at org.aspectj.runtime.reflect.JoinPointImpl.proceed(JoinPointImpl.java:149)
  ...

}}}

As you can see the test execution of the tests continued after the first assertion violation and at the end of the test execution all the assertion violations are printed.
In fact the assertion was transformed into a verify.

=== Transform Assert to Verify under the hood ===
Under the hood the code is structured in an abstract aspect ({{{org.aoplib4j.testing.internal.AbstractTestingAspect}}}) containing the flow backbone and 2 aspect (one for the JUnit testing framework and another for the TestNG testing framework) containing the specific implementation details for the JUnit and TestNG.

The aspect workflow is the following:
  * Intercept the execution of all the {{{assert*}}} methods. If the assertion is violated then keep the violation stack trace and continue the execution.
  * Intercept the execution of all testing methods. If at the end of the test execution there are any assertion violations then throw a single assert violation containing all the assert violations of the test. 

==== Intercepting {{{assert*}}} methods execution ====

As I already said, the {{{org.aoplib4j.testing.internal.AbstractTestingAspect}}} contains the backbone workflow. For the {{{assert*}}} method interception it contains an abstract pointcut and an abstract advice:

{{{
@Aspect
public abstract class AbstractTestingAspect {
...
    /**
     * Abstract pointcut representing the call of a assert method. 
     */
    @Pointcut
    public abstract void assertCallPointcut();

        /**
     * Abstract method representing the advice for the 
     * {@link #assertCallPointcut()}. Normally the child aspects should use
     * the <code>Around</code> advice to implement the behavior arround the 
     * call of the assert methods.
     *  
     * @param pjp object created by the AspectJ framework.
     * @throws Throwable the exception that can be thrown.
     * 
     */
    public abstract void assertCallAdvice(final ProceedingJoinPoint pjp) 
        throws Throwable; 
...
}
}}}

The implementation of the abstract pointcut and advice for the JUnit is the following:
{{{
@Aspect
public final class JUnitAspect extends AbstractTestingAspect { 
...
    @Pointcut("call(static public void junit.framework.Assert+.assert*(..))"
    		+ " || call(static public void org.junit.Assert+.assert*(..))")
    @Override		
    public void assertCallPointcut() {
        
    }


    @Around("assertCallPointcut()")
    @Override
    public void assertCallAdvice(final ProceedingJoinPoint pjp) 
        throws Throwable {
        
        try {
            pjp.proceed();
        } catch (AssertionFailedError junit3Error) {            
            storeErrorInformation(junit3Error);
            
            LOGGER.info("AssertionFailedError " 
                    + pjp.getSignature().toLongString());
        } catch (AssertionError junit4Error) {
            storeErrorInformation(junit4Error);
            
            LOGGER.info("AssertionFailedError " 
                    + pjp.getSignature().toLongString());
        }

    }
...
}
}}}

For the pointcut the {{{call(static public void junit.framework.Assert+.assert*(..))}}} represents the call of an assertion method under JUnit 3.x version and {{{call(static public void org.junit.Assert+.assert*(..))}}} represents an assertion call for the JUnit 4.

The advice is rather simple and clear; execute the advice containing the assertions and if the advice throws an {{{junit.framework.AssertionFailedError}}} (for JUnit 3.x) or a {{{java.lang.AssertionError}}} (for JUnit 4) store it and continue the execution.


The same elements for the TestNG framework are :
{{{
@Aspect
public final class TestNGAspect extends AbstractTestingAspect {
...

    @Pointcut("call(static public void org.testng.Assert+.assert*(..))")
    @Override
    public void assertCallPointcut() {
        
    }

    @Around("assertCallPointcut()")
    @Override
    public void assertCallAdvice(final ProceedingJoinPoint pjp) 
        throws Throwable {
        
        try {
            pjp.proceed();
        } catch (AssertionError testNGError) {
            storeErrorInformation(testNGError);
            
            LOGGER.info("AssertionFailedError " 
                    + pjp.getSignature().toLongString());
        }
    }
...
}

}}}