#summary How to use the @Aoplib4jSequenceDiagram annotation.

=== Introduction ===
This page is a small tutorial about the {{{@Aoplib4jSequenceDiagram}}} annotation.

=== How to use the {{{@Aoplib4jSequenceDiagram}}} annotation (in 2 seconds) ===

  #(*Optional*)Create your own diagram writer class extending the {{{SequenceDiagramWriter}}}.
  #Annotate the method(s) for which you want to generate the sequence diagram with the {{{@Aoplib4jSequenceDiagram}}} annotation and add as value for the {{{diagramWriter}}} attribute your own writer class name one of the writers offered by {{{AopLib4j}}}.
  #Execute the annotated method and retrieve the file representing the sequence diagram from the java.io.tmpdir folder (the diagram name is {{{ClassName.annotateMethodName().txt}}})

=== How to use the {{{@Aoplib4jSequenceDiagram}}} annotation (in 10 minutes) ===

Annotate with the {{{@Aoplib4jSequenceDiagram}}} annotation the method for which a sequence diagram should be generated. 
The annotation have a one mandatory parameter ({{{diagramWriter}}}) representing the class that will be instantiated and used for the writing of the sequence diagram and two optional parameters: {{{diagramDepth}}} representing the maximum number of participants in the diagram and {{{diagramFullPath}}} representing the full path where the diagram will be written. 

Code example of {{{Aoplib4jSequenceDiagram}}} use(taken from the JUnit tests):

{{{
public class ActorClass ...

    //Write the diagram using the SEQUENCEWriter; the diagram will be written
    //into the java.io.tmpdir/ActorClass.staticMethod().txt file
    @Aoplib4jSequenceDiagram(diagramWriter = SEQUENCEWriter.class)
    public static void staticMethod() {
    ....
    }


    //Write the diagram using the SEQUENCEWriter; the diagram will be written
    //into the /aoplib4jtests/main.seq file.
    @Aoplib4jSequenceDiagram(diagramWriter = SEQUENCEWriter.class, 
            diagramFullPath = "/aoplib4jtests/main.seq", diagramDepth = 30)
    public void actorMethod() {
    ....
    }
    
}}}  

==== Use the {{{AopLib4j}}} diagram writers ====
The {{{AopLib4j}}} library offers ~~3~~ 2 sequence writers:
 # {{{org.aoplib4j.uml.SEQUENCEWriter}}} is a writer for the [http://www.zanthan.com/itymbi/archives/cat_sequence.html SEQUENCE] project. Here is an example of a SEQUENCE diagram :
{{{

ActorClass.actorMethod() -> void{
Class1.constructor(java.lang.String str) -> void;
Class1.method1Class1() -> String;
ActorClass.[static]staticPrivateMethod(java.lang.Integer in) -> void;
}
}}}
 # {{{org.aoplib4j.uml.CodeToDiagramWriter}}} is a writer for the [http://www.assembla.com/wiki/show/codetodiagram CODETODIAGRAM] project. Here is an example of a CODETODIAGRAM diagram:
{{{
<?xml version="1.0"encoding="UTF-8"?>
<sequence>
<actors>
<actor id="org.aoplib4j.uml.codetodiagram.ActorClass" type="user">ActorClass</actor>
<actor id="org.aoplib4j.uml.Class1" type="system">Class1</actor>
</actors>
<messages>
<message type="call" from="org.aoplib4j.uml.codetodiagram.ActorClass" to="org.aoplib4j.uml.Class1" 
text="constructor(class java.lang.String)"/>
<message type="return" from="org.aoplib4j.uml.Class1" to="org.aoplib4j.uml.codetodiagram.ActorClass" 
text="constructor(class java.lang.String)"/>
<message type="call" from="org.aoplib4j.uml.codetodiagram.ActorClass" to="org.aoplib4j.uml.Class1" 
text="method1Class1()"/>
<message type="return" from="org.aoplib4j.uml.Class1" to="org.aoplib4j.uml.codetodiagram.ActorClass" 
text="method1Class1()"/>
<message type="call" from="org.aoplib4j.uml.codetodiagram.ActorClass" to="org.aoplib4j.uml.codetodiagram.ActorClass" 
text="staticPrivateMethod(class java.lang.Integer)"/>
<message type="return" from="org.aoplib4j.uml.codetodiagram.ActorClass" to="org.aoplib4j.uml.codetodiagram.ActorClass" 
text="staticPrivateMethod(class java.lang.Integer)"/>
</messages>

</sequence>

}}}

 # ~~org.aoplib4j.uml.Pic2PlotWriter~~ is a writer for the [http://www.gnu.org/software/plotutils/manual/html_chapter/plotutils_4.html GNU plotutils pic2plot]. The implementation is not completely finished (due to some complexities of the pic file format). The bug#79 contains the a patch with the partial implementation; feel free to participate/propose a new or enhanced implementation.


==== Create your own writer ===
The {{{diagramWriter}}} parameter should be a class that inherits from the {{{SequenceDiagramWriter}}} abstract class.
The most important parts of the {{{SequenceDiagramWriter}}} (the full code is here [http://code.google.com/p/aoplib4j/source/browse/trunk/aoplib4j/src/main/java/org/aoplib4j/uml/SequenceDiagramWriter.java org.aoplib4j.uml.SequenceDiagramWriter]):

{{{
public abstract class SequenceDiagramWriter {
    
    /**
     * Default constructor.
     * 
     */
    public SequenceDiagramWriter() {
    }
    
    /**
     * Write the diagram starting from the root method which is passed
     * as parameter.
     * 
     * @param rootMethod the root method; the first method of the diagram.
     * 
     * @throws IOException I/O exception if any error writing.
     */
    public abstract void write(final SequenceMethod rootMethod) 
        throws IOException;
}
}}}

The {{{SequenceMethod}}} is an interface containing informations about the annotated method. A {{{SequenceMethod}}} contains all the necessary informations concerning a sequence method: method name, method class, method is static/nonStatic/constructor, return type of the method, parameters types, parameter names, methods that
this method calls and the method that called this method.

The structure of the {{{SequenceMethod}}} interface.

{{{
public interface SequenceMethod {

    /**
     * @return the (full) class name of which this method is attached to.
     * 
     * @see #getSimpleClassName()
     */
    String getClassName();

    /**
     * @return the method name.
     */
     String getMethodName();

    /**
     * @return the method return type.
     */
    Class< ? > getReturnType();

    /**
     * @return method parameters types.
     */
    Class< ? >[] getParameterTypes();

    /**
     * @return method parameter names.
     */
    String[] getParameterNames();

    /**
     * @return the collection of children.
     */
    List<SequenceMethod> getChildren();

    /**
     * @return the parent (the caller) of this method.
     */
    SequenceMethod getParent();

    /**
     * @return true if the node have children attached, false otherwise.
     */
    boolean haveChildren();

    /**
     * @return true if the method is static, false otherwise.
     */
    boolean isStatic();

    /**
     * @return true if the method is a constructor, false otherwise
     */
    boolean isConstructor();

    /**
     * @return the simple (no package) class name; returns null if the class
     * name is null.
     */
    String getSimpleClassName();

}
}}}  

 
=== The {{{@Validate}}} annotation: under the hood ===
For the validation process the work flow is the following:
 * Intercept the assignment of a field annotated with {{{Validate}}}

   The @AspectJ pointcuts for intercepting the assignment of a field:
     * static fields
{{{
    @Pointcut(
            "set(@org.aoplib4j.fieldvalidation.Validate "
            + "static * *.*)"
            + "&& @annotation(validateAnnot) " 
            + "&& args(newValue)")
    void validateStaticFieldPointcut(
            final Validate validateAnnot, 
            final Object newValue) {
    }
}}}
     * non-static fields
{{{
    @Pointcut(
            "set(@org.aoplib4j.fieldvalidation.Validate "
            + "* *.*)" 
            + "&& @annotation(validateAnnot) " 
            + "&& args(newValue) && this(instance)")
    void validateNonStaticFieldPointcut(
            final Validate validateAnnot, 
            final Object newValue, 
            final Object instance) {
    }
}}}
   For triggering the validation the @Before advice is used.

 * Create an instance of {{{FieldInformation}}} 
 * Create an instance of {{{FieldValidator}}}
    # Retrieve the class object from the {{{validationClass}}} parameter of the annotation ( the annotation is retrieved using @AspectJ @annotation pointcut). 
    # Create a new instance by introspection (using the non argument constructor).
 * Do the validation by calling {{{FieldValidator#validate(FieldInformation fldInfor) }}} 
And here is the complete code of [http://code.google.com/p/aoplib4j/source/browse/trunk/aoplib4j/src/main/java/com/google/code/aoplib4j/aspectj/fieldvalidation/internal/FieldValidatorAspect.java FieldValidatorAspect] 

=== Critics, enhancements and ... what i don't like about this solution ===
 * The user validation class must inherit from {{{FieldValidator}}} class. It would be much better to just implement a Java interface. In the actual implementation the user must inherit from a class because the framework instantiate the validation class using the non-arguments constructor by introspection (see [http://java.sun.com/j2se/1.5.0/docs/api/java/lang/Class.html#newInstance() Class.newInstance()]). 
   